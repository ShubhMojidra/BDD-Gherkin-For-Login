"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IMAGE_STRATEGY = exports.ImageElementPlugin = void 0;
exports.getImgElFromArgs = getImgElFromArgs;
const lodash_1 = __importDefault(require("lodash"));
const driver_1 = require("appium/driver");
const support_1 = require("@appium/support");
const plugin_1 = require("appium/plugin");
const compare_1 = require("./compare");
const finder_1 = __importDefault(require("./finder"));
const image_element_1 = require("./image-element");
const constants_1 = require("./constants");
Object.defineProperty(exports, "IMAGE_STRATEGY", { enumerable: true, get: function () { return constants_1.IMAGE_STRATEGY; } });
function getImgElFromArgs(args) {
    return args.find((arg) => lodash_1.default.isString(arg) && arg.startsWith(constants_1.IMAGE_ELEMENT_PREFIX));
}
class ImageElementPlugin extends plugin_1.BasePlugin {
    constructor(pluginName) {
        super(pluginName);
        this.finder = new finder_1.default();
    }
    // this plugin supports a non-standard 'compare images' command
    static newMethodMap = /** @type {const} */ ({
        '/session/:sessionId/appium/compare_images': {
            POST: {
                command: 'compareImages',
                payloadParams: {
                    required: ['mode', 'firstImage', 'secondImage'],
                    optional: ['options'],
                },
                neverProxy: true,
            },
        },
    });
    async compareImages(next, driver, ...args) {
        // @ts-ignore Arguments should be ok there
        return await (0, compare_1.compareImages)(...args);
    }
    async findElement(next, driver, ...args) {
        return await this._find(false, next, driver, ...args);
    }
    async findElements(next, driver, ...args) {
        return await this._find(true, next, driver, ...args);
    }
    /**
     *
     * @param {boolean} multiple
     * @param {*} next
     * @param {*} driver
     * @param  {...any} args
     * @returns {Promise<any>}
     */
    async _find(multiple, next, driver, ...args) {
        const [strategy, selector] = args;
        // if we're not actually finding by image, just do the normal thing
        if (strategy !== constants_1.IMAGE_STRATEGY) {
            return await next();
        }
        return await this.finder.findByImage(Buffer.from(selector, 'base64'), driver, { multiple });
    }
    async handle(next, driver, cmdName, ...args) {
        // if we have a command that involves an image element id, attempt to find the image element
        // and execute the command on it
        const imgElId = getImgElFromArgs(args);
        if (imgElId) {
            const imgEl = this.finder.getImageElement(imgElId);
            if (!imgEl) {
                throw new driver_1.errors.NoSuchElementError();
            }
            return await image_element_1.ImageElement.execute(driver, imgEl, cmdName, ...args);
        }
        if (cmdName === 'deleteSession') {
            this.finder.clearImageElements();
        }
        // otherwise just do the normal thing
        return await next();
    }
    async performActions(next, driver, ...args) {
        // Replace with coordinates when ActionSequence includes image elements.
        const [actionSequences] = /** @type {[import('@appium/types').ActionSequence[]]} */ (args);
        for (const actionSequence of actionSequences) {
            for (const action of actionSequence.actions) {
                // The actions that can have an Element as the origin are "pointerMove" and "scroll".
                if (!lodash_1.default.isPlainObject(
                /** @type {{origin?: "viewport" | "pointer" | import('@appium/types').Element}} */ (action).origin)) {
                    continue;
                }
                const actionWithEl = 
                /** @type {import('@appium/types').PointerMoveAction | import('@appium/types').ScrollAction} */ (action);
                const elId = support_1.util.unwrapElement(/** @type {import('@appium/types').Element} */ (actionWithEl.origin));
                if (!lodash_1.default.startsWith(elId, constants_1.IMAGE_ELEMENT_PREFIX)) {
                    continue;
                }
                const imgEl = this.finder.getImageElement(elId);
                if (!imgEl) {
                    throw new driver_1.errors.NoSuchElementError();
                }
                // Add the element's center coordinates to the offset value.
                actionWithEl.x += imgEl.center.x;
                actionWithEl.y += imgEl.center.y;
                // Set the origin to the viewport so that the external driver can process it using coordinates.
                delete actionWithEl.origin;
            }
        }
        return await next();
    }
}
exports.default = ImageElementPlugin;
exports.ImageElementPlugin = ImageElementPlugin;
//# sourceMappingURL=plugin.js.map